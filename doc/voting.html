<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>voting API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>voting</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">###############################
# N round first past the post #
###############################

def N_rounds (ranked, turns):
    &#34;&#34;&#34;
    Function used for **plurality**, **two rounds**, **instant runoff**, **condorcet** and **borda** voting methods.

    *Prototype*:

    * **ranked** (*dict*) : keys are the electors, values are lists of candidates sorted by preferences
    * **turns** (*int*) : current turn (decreasing value)
    * **return** (*int*) : winning candidate

    *Notes*:

    * **N_rounds()** is recursive, the final return type differs from the others, while there are remaining turns

    *Algorithm*:
    ```
    if turns = 0 then
        return the winner
    else
        results &lt;- sorted dictionary
        // keys are the candidates and values are the number of voters for
        // whom this candidate is the favourite
        if the first candidate as more than half of the votes then
            return the winner
        else
            ranked &lt;- dictionary
            // keys are the electors, values are lists of candidates
            // sorted by preferences, last candidate is removed
            return N_rounds(ranked, turns - 1)
    ```
    &#34;&#34;&#34;
    if turns == 0:
        return ranked[0][0]
    else:
        results = {candidate:  len([elector for elector in ranked if ranked[elector][0] == candidate]) for candidate in ranked[0]}
        results = {candidate: electors for candidate, electors in sorted(results.items(), key=lambda item: item[1], reverse=True)}
        majors = [candidate for candidate in results.keys()][:turns]
        if (results[majors[0]] &gt; len(ranked)/2):
            return majors[0]
        else:
            ranked = {elector: [candidate for candidate in ranked[elector] if candidate in majors] for elector in ranked}
            return N_rounds (ranked, turns-1)

def condorcet(ranked):
    &#34;&#34;&#34;
    Function used for **condorcet** and **borda** voting methods.

    *Prototype*:

    * **ranked** (*dict*) : keys are the electors, values are lists of candidates sorted by preferences
    * **return** (*int*) : winning candidate

    *Notes*:

    * In equality cases, a recursive call is performed with the winners, as long as we can remove candidates
    * In some cases of a tie, there may not be a winner (*None* returned)

    *Algorithm*:
    ```
    pairs &lt;- list of pair of candidates
    score &lt;- dictionary
    // keys are the candidates, values are the number of duels won
    // by this candidate
    score &lt;- filtered dictionary, only the candidates with the most wins remain
    if there is only one winner then
        return the winner
    else
        subset_ranked &lt;- ranked filtered
        // by weither if the candidate is one of the winners or not
        if there is less candidates in subset_ranked than in ranked then
            return condorcet(subset_ranked)
    ```
    &#34;&#34;&#34;
    pairs = [(candidateA, candidateB) for candidateA in ranked[0] for candidateB in ranked[0] if candidateA &lt; candidateB]
    victories = {}
    score = {candidate: 0 for candidate in ranked[0]}
    for pair in pairs:
        subset_ranked = {elector: [candidate for candidate in ranked[elector] if candidate in pair] for elector in ranked}
        victories[pair] = N_rounds(subset_ranked, 1)
        score[victories[pair]] += 1
    score = {candidate: score[candidate] for candidate in score if score[candidate] == max([value for key, value in score.items()])}
    if len(score) == 1:
        return [candidate for candidate in score.keys()][0]
    subset_ranked = {elector: [candidate for candidate in ranked[elector] if candidate in [candidate for candidate in score.keys()]] for elector in ranked}
    if sorted(set(subset_ranked[0])) != sorted(set(ranked[0])):
        return (condorcet(subset_ranked))

def borda(ranked):
    &#34;&#34;&#34;
    Function used for **borda** voting method.

    *Prototype*:

    * **ranked** (*dict*) : keys are the electors, values are lists of candidates sorted by preferences
    * **return** (*int*) : winning candidate

    *Notes*:

    * In equality cases, **condorcet** method is called to decide
    * In some cases of a tie, there may not be a winner (*None* returned)

    *Algorithm*:
    ```
    results &lt;- sorted dictionary
    // keys are the candidates, values are the sum of the points given by the
    // voters for this candidate, electors give as many points as there are
    // candidates to their favorite, then one point less to the second favorite
    results &lt;- filtered dictionary
    // by weither if the candidate has the more points or not
    if there is only one winner then
        return the winner
    else
        subset_ranked &lt;- ranked filtered
        // by weither if the candidate is one of the winners or not
        return condorcet(subset_ranked)
    ```
    &#34;&#34;&#34;
    results = {candidate: 0 for candidate in ranked[0]}
    number_of_candidates = len(ranked[0])
    for elector in ranked:
        for i in range (0, number_of_candidates):
            results[ranked[elector][i]] += (number_of_candidates - i)
    results = {candidate: electors for candidate, electors in sorted(results.items(), key=lambda item: item[1], reverse=True)}
    results = {candidate: results[candidate] for candidate in results if results[candidate] == max([value for key, value in results.items()])}
    if len(results) == 1:
        return [candidate for candidate in results.keys()][0]
    else:
        subset_ranked = {elector: [candidate for candidate in ranked[elector] if candidate in [candidate for candidate in results.keys()]] for elector in ranked}
        return (condorcet(subset_ranked))

def score_voting(distances, scale_size, threshold):
    &#34;&#34;&#34;
    Function used for **approval** and **majority judgement** voting methods.

    *Prototype*:

    * **ranked** (*dict*) : keys are the electors, values are dictionaries whose keys are candidates and values are the distance between the elector and the candidate
    * **scale_size** (*int*) : number of areas into which to divide the position space, must be strictly greater than 1
    * **threshold** (*float*) : rejection threshold
    * **return** (*dict*) : keys are the candidates, values are lists indexed by the scores, from the better to the worst, elements of the lists are the number of voters giving this score to the candidate

    *Notes*:

    * If the position space is divided into N areas, there will be N-1 areas below the rejection threshold, and one above
    * As the position space is divided in areas, it doesn&#39;t matter if it corresponds to notes or mentions

    *Algorithm*:
    ```
    for each candidate, for each elector
        for i in areas
            if the distance between the two is in this areas then
                results for this candidate for this areas increments
        if the distance is strictly greater than the rejection threshold then
            results for this candidate for the threshold increments
    return results
    ```
    &#34;&#34;&#34;
    results = {c: [0 for i in range(0, scale_size)] for c in distances[0]}
    for c in distances[0]:
        for e in distances:
            for i in range(0, scale_size-1):
                if i*threshold/(scale_size-1) &lt; distances[e][c] &lt;= (i+1)*threshold/(scale_size-1):
                    results[c][i] +=1
            if distances[e][c] &gt; threshold:
                results[c][scale_size-1] += 1
    return results

def approval (distances, threshold):
    &#34;&#34;&#34;
    Function used for **approval** voting method.

    *Prototype*:

    * **ranked** (*dict*) : keys are the electors, values are dictionaries whose keys are candidates and values are the distance between the elector and the candidate
    * **threshold** (*float*) : rejection threshold
    * **return** (*int*) : winning candidate

    *Notes*:

    * In some cases of a tie, there may not be a winner (*None* returned)

    *Algorithm*:
    ```pseudo-code
    results &lt;- score_voting(distances, scale=2, threshold)
    winner &lt;- list of candidates with the most votes in the first grade
    if there is only one winner then
        return the winner
    ```
    &#34;&#34;&#34;
    scale = 2
    results = score_voting(distances, scale, threshold)
    winner = [c for c in distances[0] if results[c][0] == max([results[c][0] for c in distances[0]])]
    if len(winner) == 1:
        return winner[0]

def majority_judgement (distances, threshold):
    &#34;&#34;&#34;
    Function used for **majority judgement** voting method.

    *Prototype*:

    * **ranked** (*dict*) : keys are the electors, values are dictionaries whose keys are candidates and values are the distance between the elector and the candidate
    * **threshold** (*float*) : rejection threshold
    * **return** (*int*) : winning candidate

    *Notes*:

    * The number of mentions is 6, so there is no &#34;middle mention&#34;
    * The tie-breaking is done by minimizing the number of opponents (i.e the number of electors that gave a lesser mention that the majority mention)
    * The second tie-breaking, if necessary, is done by maximizing the number of supporters (i.e the number of electors that gave a better mention)
    * In some cases of a tie, there may not be a winner (*None* returned)
    * Because of the space of the positions, the majority mention of the best candidates can be the rejection

    *Algorithm*:
    ```
    results &lt;- score_voting(distances, scale=6, threshold)
    cumulative &lt;- dictionary
    // keys are the candidates, values are lists indexed by the mentions, from
    // the better to the worst, elements of the lists are the number of voters
    // giving at least this mention to the candidate
    majority_mentions &lt;- dictionary
    // keys are the candidates, values are the majority mentions
    winner &lt;- list of candidates with the better majority mention
    if the better majority mentions is better than rejection then
        opponents &lt;- dictionary
        // keys are candidates, values are the number of opponents
        winner &lt;- filtered winner
        // by weither if the candidate has the minimum of opponents
        if there is only one winner then
            return the winner
    partisants &lt;- dictionary
    // keys are candidates, values are the number of partisants
    winner &lt;- filtered winner
    // by weither if the candidate has the maximum of partisants
    if there is only one winner then
        return the winner
    ```
    &#34;&#34;&#34;
    scale = 6
    results = score_voting(distances, scale, threshold)
    cumulative = {c: [sum(results[c][:i+1]) for i in range(0, scale)] for c in results}
    majority_mentions = {c: i for i in range(scale-1, -1, -1) for c in results if cumulative[c][i] &gt; len(distances)/2}
    winners = [c for c in majority_mentions if majority_mentions[c] == min([majority_mentions[c] for c in majority_mentions])]
    if majority_mentions[winners[0]] != scale-1:
        opponents = {c: sum(results[c][majority_mentions[c]+1:]) for c in winners}
        winners = [c for c in winners if opponents[c] == min([opponents[c] for c in winners])]
        if len(winners) == 1:
            return winners[0]
    partisants = {c: sum(results[c][:majority_mentions[c]]) for c in winners}
    winners = [c for c in winners if partisants[c] == max([partisants[c] for c in winners])]
    if len(winners) == 1:
        return winners[0]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="voting.N_rounds"><code class="name flex">
<span>def <span class="ident">N_rounds</span></span>(<span>ranked, turns)</span>
</code></dt>
<dd>
<div class="desc"><p>Function used for <strong>plurality</strong>, <strong>two rounds</strong>, <strong>instant runoff</strong>, <strong>condorcet</strong> and <strong>borda</strong> voting methods.</p>
<p><em>Prototype</em>:</p>
<ul>
<li><strong>ranked</strong> (<em>dict</em>) : keys are the electors, values are lists of candidates sorted by preferences</li>
<li><strong>turns</strong> (<em>int</em>) : current turn (decreasing value)</li>
<li><strong>return</strong> (<em>int</em>) : winning candidate</li>
</ul>
<p><em>Notes</em>:</p>
<ul>
<li><strong>N_rounds()</strong> is recursive, the final return type differs from the others, while there are remaining turns</li>
</ul>
<p><em>Algorithm</em>:</p>
<pre><code>if turns = 0 then
    return the winner
else
    results &lt;- sorted dictionary
    // keys are the candidates and values are the number of voters for
    // whom this candidate is the favourite
    if the first candidate as more than half of the votes then
        return the winner
    else
        ranked &lt;- dictionary
        // keys are the electors, values are lists of candidates
        // sorted by preferences, last candidate is removed
        return N_rounds(ranked, turns - 1)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def N_rounds (ranked, turns):
    &#34;&#34;&#34;
    Function used for **plurality**, **two rounds**, **instant runoff**, **condorcet** and **borda** voting methods.

    *Prototype*:

    * **ranked** (*dict*) : keys are the electors, values are lists of candidates sorted by preferences
    * **turns** (*int*) : current turn (decreasing value)
    * **return** (*int*) : winning candidate

    *Notes*:

    * **N_rounds()** is recursive, the final return type differs from the others, while there are remaining turns

    *Algorithm*:
    ```
    if turns = 0 then
        return the winner
    else
        results &lt;- sorted dictionary
        // keys are the candidates and values are the number of voters for
        // whom this candidate is the favourite
        if the first candidate as more than half of the votes then
            return the winner
        else
            ranked &lt;- dictionary
            // keys are the electors, values are lists of candidates
            // sorted by preferences, last candidate is removed
            return N_rounds(ranked, turns - 1)
    ```
    &#34;&#34;&#34;
    if turns == 0:
        return ranked[0][0]
    else:
        results = {candidate:  len([elector for elector in ranked if ranked[elector][0] == candidate]) for candidate in ranked[0]}
        results = {candidate: electors for candidate, electors in sorted(results.items(), key=lambda item: item[1], reverse=True)}
        majors = [candidate for candidate in results.keys()][:turns]
        if (results[majors[0]] &gt; len(ranked)/2):
            return majors[0]
        else:
            ranked = {elector: [candidate for candidate in ranked[elector] if candidate in majors] for elector in ranked}
            return N_rounds (ranked, turns-1)</code></pre>
</details>
</dd>
<dt id="voting.approval"><code class="name flex">
<span>def <span class="ident">approval</span></span>(<span>distances, threshold)</span>
</code></dt>
<dd>
<div class="desc"><p>Function used for <strong>approval</strong> voting method.</p>
<p><em>Prototype</em>:</p>
<ul>
<li><strong>ranked</strong> (<em>dict</em>) : keys are the electors, values are dictionaries whose keys are candidates and values are the distance between the elector and the candidate</li>
<li><strong>threshold</strong> (<em>float</em>) : rejection threshold</li>
<li><strong>return</strong> (<em>int</em>) : winning candidate</li>
</ul>
<p><em>Notes</em>:</p>
<ul>
<li>In some cases of a tie, there may not be a winner (<em>None</em> returned)</li>
</ul>
<p><em>Algorithm</em>:</p>
<pre><code class="language-pseudo-code">results &lt;- score_voting(distances, scale=2, threshold)
winner &lt;- list of candidates with the most votes in the first grade
if there is only one winner then
    return the winner
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approval (distances, threshold):
    &#34;&#34;&#34;
    Function used for **approval** voting method.

    *Prototype*:

    * **ranked** (*dict*) : keys are the electors, values are dictionaries whose keys are candidates and values are the distance between the elector and the candidate
    * **threshold** (*float*) : rejection threshold
    * **return** (*int*) : winning candidate

    *Notes*:

    * In some cases of a tie, there may not be a winner (*None* returned)

    *Algorithm*:
    ```pseudo-code
    results &lt;- score_voting(distances, scale=2, threshold)
    winner &lt;- list of candidates with the most votes in the first grade
    if there is only one winner then
        return the winner
    ```
    &#34;&#34;&#34;
    scale = 2
    results = score_voting(distances, scale, threshold)
    winner = [c for c in distances[0] if results[c][0] == max([results[c][0] for c in distances[0]])]
    if len(winner) == 1:
        return winner[0]</code></pre>
</details>
</dd>
<dt id="voting.borda"><code class="name flex">
<span>def <span class="ident">borda</span></span>(<span>ranked)</span>
</code></dt>
<dd>
<div class="desc"><p>Function used for <strong>borda</strong> voting method.</p>
<p><em>Prototype</em>:</p>
<ul>
<li><strong>ranked</strong> (<em>dict</em>) : keys are the electors, values are lists of candidates sorted by preferences</li>
<li><strong>return</strong> (<em>int</em>) : winning candidate</li>
</ul>
<p><em>Notes</em>:</p>
<ul>
<li>In equality cases, <strong>condorcet</strong> method is called to decide</li>
<li>In some cases of a tie, there may not be a winner (<em>None</em> returned)</li>
</ul>
<p><em>Algorithm</em>:</p>
<pre><code>results &lt;- sorted dictionary
// keys are the candidates, values are the sum of the points given by the
// voters for this candidate, electors give as many points as there are
// candidates to their favorite, then one point less to the second favorite
results &lt;- filtered dictionary
// by weither if the candidate has the more points or not
if there is only one winner then
    return the winner
else
    subset_ranked &lt;- ranked filtered
    // by weither if the candidate is one of the winners or not
    return condorcet(subset_ranked)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def borda(ranked):
    &#34;&#34;&#34;
    Function used for **borda** voting method.

    *Prototype*:

    * **ranked** (*dict*) : keys are the electors, values are lists of candidates sorted by preferences
    * **return** (*int*) : winning candidate

    *Notes*:

    * In equality cases, **condorcet** method is called to decide
    * In some cases of a tie, there may not be a winner (*None* returned)

    *Algorithm*:
    ```
    results &lt;- sorted dictionary
    // keys are the candidates, values are the sum of the points given by the
    // voters for this candidate, electors give as many points as there are
    // candidates to their favorite, then one point less to the second favorite
    results &lt;- filtered dictionary
    // by weither if the candidate has the more points or not
    if there is only one winner then
        return the winner
    else
        subset_ranked &lt;- ranked filtered
        // by weither if the candidate is one of the winners or not
        return condorcet(subset_ranked)
    ```
    &#34;&#34;&#34;
    results = {candidate: 0 for candidate in ranked[0]}
    number_of_candidates = len(ranked[0])
    for elector in ranked:
        for i in range (0, number_of_candidates):
            results[ranked[elector][i]] += (number_of_candidates - i)
    results = {candidate: electors for candidate, electors in sorted(results.items(), key=lambda item: item[1], reverse=True)}
    results = {candidate: results[candidate] for candidate in results if results[candidate] == max([value for key, value in results.items()])}
    if len(results) == 1:
        return [candidate for candidate in results.keys()][0]
    else:
        subset_ranked = {elector: [candidate for candidate in ranked[elector] if candidate in [candidate for candidate in results.keys()]] for elector in ranked}
        return (condorcet(subset_ranked))</code></pre>
</details>
</dd>
<dt id="voting.condorcet"><code class="name flex">
<span>def <span class="ident">condorcet</span></span>(<span>ranked)</span>
</code></dt>
<dd>
<div class="desc"><p>Function used for <strong>condorcet</strong> and <strong>borda</strong> voting methods.</p>
<p><em>Prototype</em>:</p>
<ul>
<li><strong>ranked</strong> (<em>dict</em>) : keys are the electors, values are lists of candidates sorted by preferences</li>
<li><strong>return</strong> (<em>int</em>) : winning candidate</li>
</ul>
<p><em>Notes</em>:</p>
<ul>
<li>In equality cases, a recursive call is performed with the winners, as long as we can remove candidates</li>
<li>In some cases of a tie, there may not be a winner (<em>None</em> returned)</li>
</ul>
<p><em>Algorithm</em>:</p>
<pre><code>pairs &lt;- list of pair of candidates
score &lt;- dictionary
// keys are the candidates, values are the number of duels won
// by this candidate
score &lt;- filtered dictionary, only the candidates with the most wins remain
if there is only one winner then
    return the winner
else
    subset_ranked &lt;- ranked filtered
    // by weither if the candidate is one of the winners or not
    if there is less candidates in subset_ranked than in ranked then
        return condorcet(subset_ranked)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def condorcet(ranked):
    &#34;&#34;&#34;
    Function used for **condorcet** and **borda** voting methods.

    *Prototype*:

    * **ranked** (*dict*) : keys are the electors, values are lists of candidates sorted by preferences
    * **return** (*int*) : winning candidate

    *Notes*:

    * In equality cases, a recursive call is performed with the winners, as long as we can remove candidates
    * In some cases of a tie, there may not be a winner (*None* returned)

    *Algorithm*:
    ```
    pairs &lt;- list of pair of candidates
    score &lt;- dictionary
    // keys are the candidates, values are the number of duels won
    // by this candidate
    score &lt;- filtered dictionary, only the candidates with the most wins remain
    if there is only one winner then
        return the winner
    else
        subset_ranked &lt;- ranked filtered
        // by weither if the candidate is one of the winners or not
        if there is less candidates in subset_ranked than in ranked then
            return condorcet(subset_ranked)
    ```
    &#34;&#34;&#34;
    pairs = [(candidateA, candidateB) for candidateA in ranked[0] for candidateB in ranked[0] if candidateA &lt; candidateB]
    victories = {}
    score = {candidate: 0 for candidate in ranked[0]}
    for pair in pairs:
        subset_ranked = {elector: [candidate for candidate in ranked[elector] if candidate in pair] for elector in ranked}
        victories[pair] = N_rounds(subset_ranked, 1)
        score[victories[pair]] += 1
    score = {candidate: score[candidate] for candidate in score if score[candidate] == max([value for key, value in score.items()])}
    if len(score) == 1:
        return [candidate for candidate in score.keys()][0]
    subset_ranked = {elector: [candidate for candidate in ranked[elector] if candidate in [candidate for candidate in score.keys()]] for elector in ranked}
    if sorted(set(subset_ranked[0])) != sorted(set(ranked[0])):
        return (condorcet(subset_ranked))</code></pre>
</details>
</dd>
<dt id="voting.majority_judgement"><code class="name flex">
<span>def <span class="ident">majority_judgement</span></span>(<span>distances, threshold)</span>
</code></dt>
<dd>
<div class="desc"><p>Function used for <strong>majority judgement</strong> voting method.</p>
<p><em>Prototype</em>:</p>
<ul>
<li><strong>ranked</strong> (<em>dict</em>) : keys are the electors, values are dictionaries whose keys are candidates and values are the distance between the elector and the candidate</li>
<li><strong>threshold</strong> (<em>float</em>) : rejection threshold</li>
<li><strong>return</strong> (<em>int</em>) : winning candidate</li>
</ul>
<p><em>Notes</em>:</p>
<ul>
<li>The number of mentions is 6, so there is no "middle mention"</li>
<li>The tie-breaking is done by minimizing the number of opponents (i.e the number of electors that gave a lesser mention that the majority mention)</li>
<li>The second tie-breaking, if necessary, is done by maximizing the number of supporters (i.e the number of electors that gave a better mention)</li>
<li>In some cases of a tie, there may not be a winner (<em>None</em> returned)</li>
<li>Because of the space of the positions, the majority mention of the best candidates can be the rejection</li>
</ul>
<p><em>Algorithm</em>:</p>
<pre><code>results &lt;- score_voting(distances, scale=6, threshold)
cumulative &lt;- dictionary
// keys are the candidates, values are lists indexed by the mentions, from
// the better to the worst, elements of the lists are the number of voters
// giving at least this mention to the candidate
majority_mentions &lt;- dictionary
// keys are the candidates, values are the majority mentions
winner &lt;- list of candidates with the better majority mention
if the better majority mentions is better than rejection then
    opponents &lt;- dictionary
    // keys are candidates, values are the number of opponents
    winner &lt;- filtered winner
    // by weither if the candidate has the minimum of opponents
    if there is only one winner then
        return the winner
partisants &lt;- dictionary
// keys are candidates, values are the number of partisants
winner &lt;- filtered winner
// by weither if the candidate has the maximum of partisants
if there is only one winner then
    return the winner
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def majority_judgement (distances, threshold):
    &#34;&#34;&#34;
    Function used for **majority judgement** voting method.

    *Prototype*:

    * **ranked** (*dict*) : keys are the electors, values are dictionaries whose keys are candidates and values are the distance between the elector and the candidate
    * **threshold** (*float*) : rejection threshold
    * **return** (*int*) : winning candidate

    *Notes*:

    * The number of mentions is 6, so there is no &#34;middle mention&#34;
    * The tie-breaking is done by minimizing the number of opponents (i.e the number of electors that gave a lesser mention that the majority mention)
    * The second tie-breaking, if necessary, is done by maximizing the number of supporters (i.e the number of electors that gave a better mention)
    * In some cases of a tie, there may not be a winner (*None* returned)
    * Because of the space of the positions, the majority mention of the best candidates can be the rejection

    *Algorithm*:
    ```
    results &lt;- score_voting(distances, scale=6, threshold)
    cumulative &lt;- dictionary
    // keys are the candidates, values are lists indexed by the mentions, from
    // the better to the worst, elements of the lists are the number of voters
    // giving at least this mention to the candidate
    majority_mentions &lt;- dictionary
    // keys are the candidates, values are the majority mentions
    winner &lt;- list of candidates with the better majority mention
    if the better majority mentions is better than rejection then
        opponents &lt;- dictionary
        // keys are candidates, values are the number of opponents
        winner &lt;- filtered winner
        // by weither if the candidate has the minimum of opponents
        if there is only one winner then
            return the winner
    partisants &lt;- dictionary
    // keys are candidates, values are the number of partisants
    winner &lt;- filtered winner
    // by weither if the candidate has the maximum of partisants
    if there is only one winner then
        return the winner
    ```
    &#34;&#34;&#34;
    scale = 6
    results = score_voting(distances, scale, threshold)
    cumulative = {c: [sum(results[c][:i+1]) for i in range(0, scale)] for c in results}
    majority_mentions = {c: i for i in range(scale-1, -1, -1) for c in results if cumulative[c][i] &gt; len(distances)/2}
    winners = [c for c in majority_mentions if majority_mentions[c] == min([majority_mentions[c] for c in majority_mentions])]
    if majority_mentions[winners[0]] != scale-1:
        opponents = {c: sum(results[c][majority_mentions[c]+1:]) for c in winners}
        winners = [c for c in winners if opponents[c] == min([opponents[c] for c in winners])]
        if len(winners) == 1:
            return winners[0]
    partisants = {c: sum(results[c][:majority_mentions[c]]) for c in winners}
    winners = [c for c in winners if partisants[c] == max([partisants[c] for c in winners])]
    if len(winners) == 1:
        return winners[0]</code></pre>
</details>
</dd>
<dt id="voting.score_voting"><code class="name flex">
<span>def <span class="ident">score_voting</span></span>(<span>distances, scale_size, threshold)</span>
</code></dt>
<dd>
<div class="desc"><p>Function used for <strong>approval</strong> and <strong>majority judgement</strong> voting methods.</p>
<p><em>Prototype</em>:</p>
<ul>
<li><strong>ranked</strong> (<em>dict</em>) : keys are the electors, values are dictionaries whose keys are candidates and values are the distance between the elector and the candidate</li>
<li><strong>scale_size</strong> (<em>int</em>) : number of areas into which to divide the position space, must be strictly greater than 1</li>
<li><strong>threshold</strong> (<em>float</em>) : rejection threshold</li>
<li><strong>return</strong> (<em>dict</em>) : keys are the candidates, values are lists indexed by the scores, from the better to the worst, elements of the lists are the number of voters giving this score to the candidate</li>
</ul>
<p><em>Notes</em>:</p>
<ul>
<li>If the position space is divided into N areas, there will be N-1 areas below the rejection threshold, and one above</li>
<li>As the position space is divided in areas, it doesn't matter if it corresponds to notes or mentions</li>
</ul>
<p><em>Algorithm</em>:</p>
<pre><code>for each candidate, for each elector
    for i in areas
        if the distance between the two is in this areas then
            results for this candidate for this areas increments
    if the distance is strictly greater than the rejection threshold then
        results for this candidate for the threshold increments
return results
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def score_voting(distances, scale_size, threshold):
    &#34;&#34;&#34;
    Function used for **approval** and **majority judgement** voting methods.

    *Prototype*:

    * **ranked** (*dict*) : keys are the electors, values are dictionaries whose keys are candidates and values are the distance between the elector and the candidate
    * **scale_size** (*int*) : number of areas into which to divide the position space, must be strictly greater than 1
    * **threshold** (*float*) : rejection threshold
    * **return** (*dict*) : keys are the candidates, values are lists indexed by the scores, from the better to the worst, elements of the lists are the number of voters giving this score to the candidate

    *Notes*:

    * If the position space is divided into N areas, there will be N-1 areas below the rejection threshold, and one above
    * As the position space is divided in areas, it doesn&#39;t matter if it corresponds to notes or mentions

    *Algorithm*:
    ```
    for each candidate, for each elector
        for i in areas
            if the distance between the two is in this areas then
                results for this candidate for this areas increments
        if the distance is strictly greater than the rejection threshold then
            results for this candidate for the threshold increments
    return results
    ```
    &#34;&#34;&#34;
    results = {c: [0 for i in range(0, scale_size)] for c in distances[0]}
    for c in distances[0]:
        for e in distances:
            for i in range(0, scale_size-1):
                if i*threshold/(scale_size-1) &lt; distances[e][c] &lt;= (i+1)*threshold/(scale_size-1):
                    results[c][i] +=1
            if distances[e][c] &gt; threshold:
                results[c][scale_size-1] += 1
    return results</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="voting.N_rounds" href="#voting.N_rounds">N_rounds</a></code></li>
<li><code><a title="voting.approval" href="#voting.approval">approval</a></code></li>
<li><code><a title="voting.borda" href="#voting.borda">borda</a></code></li>
<li><code><a title="voting.condorcet" href="#voting.condorcet">condorcet</a></code></li>
<li><code><a title="voting.majority_judgement" href="#voting.majority_judgement">majority_judgement</a></code></li>
<li><code><a title="voting.score_voting" href="#voting.score_voting">score_voting</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>